This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T16:40:32.894Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cat_emails.egg-info/
  dependency_links.txt
  PKG-INFO
  requires.txt
  SOURCES.txt
  top_level.txt
models/
  categorized_email.py
  email_category.py
scratch/
  ollama-example.py
tests/
  __init__.py
  test_domain_service.py
.env.example
.gitignore
.repomixignore
Dockerfile
Dockerfile.test
domain_service.py
email_scanner_consumer.py
email_scanner_producer.py
gmail_fetcher.py
Makefile
README.md
requirements.txt
send_email_to_kafka.py
setup.py

================================================================
Repository Files
================================================================

================
File: cat_emails.egg-info/dependency_links.txt
================


================
File: cat_emails.egg-info/PKG-INFO
================
Metadata-Version: 2.1
Name: cat-emails
Version: 0.1
Requires-Dist: requests>=2.26.0
Requires-Dist: requests-mock>=1.11.0
Requires-Dist: pydantic>=2.9.2

================
File: cat_emails.egg-info/requires.txt
================
requests>=2.26.0
requests-mock>=1.11.0
pydantic>=2.9.2

================
File: cat_emails.egg-info/SOURCES.txt
================
.env.example
.gitignore
Dockerfile
Makefile
README.md
email_scanner_consumer.py
email_scanner_producer.py
gmail_fetcher.py
requirements.txt
send_email_to_kafka.py
setup.py
cat_emails.egg-info/PKG-INFO
cat_emails.egg-info/SOURCES.txt
cat_emails.egg-info/dependency_links.txt
cat_emails.egg-info/requires.txt
cat_emails.egg-info/top_level.txt
models/categorized_email.py
models/email_category.py
scratch/ollama-example.py
tests/__init__.py
tests/test_domain_service.py

================
File: cat_emails.egg-info/top_level.txt
================
tests

================
File: models/categorized_email.py
================
from models.email_category import EmailCategory
from pydantic import BaseModel, Field

class CategorizedEmail(BaseModel):
    contents: str = Field(description="The contents of the email")
    category: EmailCategory = Field(description="The category of the email.")

================
File: models/email_category.py
================
from enum import Enum, auto
from difflib import get_close_matches

class EmailCategory(Enum):
    FINANCIAL = auto()
    ADMINISTRATIVE = auto()
    HEALTH_WELLNESS = auto()
    EDUCATION = auto()
    PERSONAL_COMMITMENTS = auto()
    HOME_MANAGEMENT = auto()
    WORK_RELATED = auto()
    CONSUMER_ACTION = auto()
    SUBSCRIPTIONS_MEMBERSHIPS = auto()
    PERSONAL_CORRESPONDENCE = auto()

    @classmethod
    def from_string(cls, category_string: str, fuzzy_match: bool = False) -> 'EmailCategory':
        """
        Convert a string to an EmailCategory enum.
        The conversion is case-insensitive and ignores spaces and underscores.
        If fuzzy_match is True, it will return the closest matching category.
        """
        category_string = category_string.lower().replace(' ', '').replace('_', '')
        for category in cls:
            if category.name.lower().replace('_', '') == category_string:
                return category
        
        if fuzzy_match:
            return cls.fuzzy_match(category_string)
        
        raise ValueError(f"'{category_string}' is not a valid EmailCategory")

    @classmethod
    def fuzzy_match(cls, category_string: str) -> 'EmailCategory':
        """
        Find the closest matching EmailCategory for the given string.
        """
        valid_categories = [category.name.lower().replace('_', '') for category in cls]
        matches = get_close_matches(category_string, valid_categories, n=1, cutoff=0.6)
        
        if matches:
            for category in cls:
                if category.name.lower().replace('_', '') == matches[0]:
                    return category
        
        raise ValueError(f"No close match found for '{category_string}'")

    @classmethod
    def all_categories(cls, separator: str = ", ") -> str:
        """
        Return all category names as a single joined string.
        """
        return separator.join(category.name for category in cls)

# # Example usage
# if __name__ == "__main__":
#     # Using the enum
#     print(EmailCategory.FINANCIAL)
#     print(EmailCategory.HEALTH_WELLNESS)

#     # Converting strings to enums
#     print(EmailCategory.from_string("Financial"))
#     print(EmailCategory.from_string("Health Wellness"))
#     print(EmailCategory.from_string("personal_commitments"))

#     # Using fuzzy matching
#     print(EmailCategory.from_string("finance", fuzzy_match=True))
#     print(EmailCategory.from_string("health", fuzzy_match=True))
#     print(EmailCategory.from_string("education stuff", fuzzy_match=True))

#     # Get all categories as a string
#     print("\nAll categories:")
#     print(EmailCategory.all_categories())

#     # Get all categories with a custom separator
#     print("\nAll categories (custom separator):")
#     print(EmailCategory.all_categories(" | "))

#     # This will raise a ValueError
#     # print(EmailCategory.from_string("Invalid Category"))

#     # This will also raise a ValueError (no close match)
#     # print(EmailCategory.from_string("xyz", fuzzy_match=True))

================
File: scratch/ollama-example.py
================
import ell
import openai

ell.init(verbose=True, store='./logdir')

client = openai.Client(
    base_url="http://10.1.1.144:11434/v1", api_key="ollama"  # required but not used
)

@ell.simple(model="llama3.2:latest", temperature=0.5, client=client)
def categorize_email(contents: str):
    """
    You do not want people trying to sell you things.
    You do not want to spend money.
    You categorize emails into one of the following categories: 
    'Wants-Money', 'Marketing', 'Personal', 'Financial-Notification', 'Appointment-Reminder', 'Service-Updates', 'Work-related'.
    """
    return f"Categorize this email. You are limited into one of the categories. Maximum length of response is 2 words: {contents}"

contents = """

Your next adventure is waiting, and Hemispheres can help you make it happen.
 
With Hemispheres®, get expert travel advice and insider recommendations for hotels, food, activities and more at your favorite United destinations. Our Three Perfect Days® feature even offers curated itineraries to make the most of your trip, no matter how much time you have.

Once you’ve imagined the perfect trip, book your flight on United and make it a reality.
"""

category = categorize_email(contents)
print(category)

================
File: tests/__init__.py
================


================
File: tests/test_domain_service.py
================
import unittest
from unittest.mock import patch, Mock
import requests

from domain_service import DomainService, AllowedDomain, BlockedDomain, BlockedCategory

class TestDomainService(unittest.TestCase):
    def setUp(self):
        self.service = DomainService()

    def test_base_url_normalization(self):
        """Test that base URL is properly normalized."""
        service = DomainService("https://control-api.joseserver.com/")
        self.assertEqual(service.base_url, "https://control-api.joseserver.com")

    @patch('requests.get')
    def test_fetch_allowed_domains_success(self, mock_get):
        """Test successful fetch of allowed domains."""
        mock_response = Mock()
        mock_response.json.return_value = [
            {"domain": "example.com", "is_active": True},
            {"domain": "test.com", "is_active": False}
        ]
        mock_get.return_value = mock_response

        domains = self.service.fetch_allowed_domains()
        self.assertEqual(len(domains), 2)
        self.assertEqual(domains[0].domain, "example.com")
        self.assertTrue(domains[0].is_active)

        mock_get.assert_called_with(
            "https://control-api.joseserver.com/api/v1/domains/allowed",
            timeout=10,
            headers={'Accept': 'application/json'}
        )

    @patch('requests.get')
    def test_fetch_allowed_domains_http_error(self, mock_get):
        """Test handling of HTTP errors."""
        mock_get.side_effect = requests.RequestException("API error")
        with self.assertRaises(requests.RequestException):
            self.service.fetch_allowed_domains()

    @patch('requests.get')
    def test_fetch_allowed_domains_invalid_response(self, mock_get):
        """Test handling of invalid response data."""
        mock_response = Mock()
        mock_response.json.return_value = {"error": "not a list"}
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_allowed_domains()

    @patch('requests.get')
    def test_fetch_allowed_domains_invalid_domain_data(self, mock_get):
        """Test handling of invalid domain data within the array."""
        mock_response = Mock()
        mock_response.json.return_value = [{"invalid": "data"}]
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_allowed_domains()

    @patch('requests.get')
    def test_fetch_blocked_domains_success(self, mock_get):
        """Test successful fetch of blocked domains."""
        mock_response = Mock()
        mock_response.json.return_value = [
            {"domain": "spam.com", "reason": "Spam source"},
            {"domain": "malware.com", "reason": "Malware host"}
        ]
        mock_get.return_value = mock_response

        domains = self.service.fetch_blocked_domains()
        self.assertEqual(len(domains), 2)
        self.assertEqual(domains[0].domain, "spam.com")
        self.assertEqual(domains[0].reason, "Spam source")

        mock_get.assert_called_with(
            "https://control-api.joseserver.com/api/v1/domains/blocked",
            timeout=10,
            headers={'Accept': 'application/json'}
        )

    @patch('requests.get')
    def test_fetch_blocked_domains_http_error(self, mock_get):
        """Test handling of HTTP errors for blocked domains."""
        mock_get.side_effect = requests.RequestException("API error")
        with self.assertRaises(requests.RequestException):
            self.service.fetch_blocked_domains()

    @patch('requests.get')
    def test_fetch_blocked_domains_invalid_response(self, mock_get):
        """Test handling of invalid response data for blocked domains."""
        mock_response = Mock()
        mock_response.json.return_value = {"error": "not a list"}
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_blocked_domains()

    @patch('requests.get')
    def test_fetch_blocked_domains_invalid_domain_data(self, mock_get):
        """Test handling of invalid domain data within the array for blocked domains."""
        mock_response = Mock()
        mock_response.json.return_value = [{"invalid": "data"}]
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_blocked_domains()

    @patch('requests.get')
    def test_fetch_blocked_categories_success(self, mock_get):
        """Test successful fetch of blocked categories."""
        mock_response = Mock()
        mock_response.json.return_value = [
            {
                "name": "Malware",
                "description": "Known malware distribution sites",
                "severity": "high"
            },
            {
                "name": "Phishing",
                "description": "Phishing attempt sites",
                "severity": "critical"
            }
        ]
        mock_get.return_value = mock_response

        categories = self.service.fetch_blocked_categories()
        self.assertEqual(len(categories), 2)
        self.assertEqual(categories[0].name, "Malware")
        self.assertEqual(categories[0].description, "Known malware distribution sites")
        self.assertEqual(categories[0].severity, "high")

        mock_get.assert_called_with(
            "https://control-api.joseserver.com/api/v1/categories/blocked",
            timeout=10,
            headers={'Accept': 'application/json'}
        )

    @patch('requests.get')
    def test_fetch_blocked_categories_http_error(self, mock_get):
        """Test handling of HTTP errors for blocked categories."""
        mock_get.side_effect = requests.RequestException("API error")
        with self.assertRaises(requests.RequestException):
            self.service.fetch_blocked_categories()

    @patch('requests.get')
    def test_fetch_blocked_categories_invalid_response(self, mock_get):
        """Test handling of invalid response data for blocked categories."""
        mock_response = Mock()
        mock_response.json.return_value = {"error": "not a list"}
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_blocked_categories()

    @patch('requests.get')
    def test_fetch_blocked_categories_invalid_category_data(self, mock_get):
        """Test handling of invalid category data within the array."""
        mock_response = Mock()
        mock_response.json.return_value = [{"invalid": "data"}]
        mock_get.return_value = mock_response

        with self.assertRaises(ValueError):
            self.service.fetch_blocked_categories()

if __name__ == '__main__':
    unittest.main()

================
File: .env.example
================
# Gmail Categorizer Environment Variables

# Your Gmail email address
GMAIL_EMAIL=your.email@gmail.com

# Your Gmail password or app-specific password
GMAIL_PASSWORD=your_password_or_app_specific_password

# Note: Replace the values above with your actual Gmail credentials
# Do not commit the actual .env file with real credentials to version control

================
File: .gitignore
================
.aider*
.env
nohup.out
ollama.txt
logdir
__pycache__/

================
File: .repomixignore
================
venv
logdir
.aider*

================
File: Dockerfile
================
FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y \
    gcc \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install -U "ell-ai[all]"

COPY gmail_fetcher.py .

ENV GMAIL_EMAIL=""
ENV GMAIL_PASSWORD=""
ENV PYTHONUNBUFFERED=1

ENTRYPOINT ["python", "gmail_fetcher.py"]

================
File: Dockerfile.test
================
FROM python:3.11-slim

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install dependencies
COPY requirements.txt .
COPY setup.py .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install -e .

# Copy source code and tests
COPY . .

# Run the tests
CMD ["python", "-m", "unittest", "discover", "-v", "tests"]

================
File: domain_service.py
================
import requests
from typing import List, Type
from pydantic import BaseModel, Field

class AllowedDomain(BaseModel):
    domain: str = Field(description="The domain name")
    is_active: bool = Field(description="Whether the domain is active")

class BlockedDomain(BaseModel):
    domain: str = Field(description="The domain name")
    reason: str = Field(description="The reason for blocking this domain")

class BlockedCategory(BaseModel):
    name: str = Field(description="The category name")
    description: str = Field(description="Description of the category")
    severity: str = Field(description="Severity level of the category")

class DomainService:
    def __init__(self, base_url: str = "https://control-api.joseserver.com"):
        self.base_url = base_url.rstrip('/')
        
    def fetch_allowed_domains(self) -> List[AllowedDomain]:
        return self._fetch_domains("/api/v1/domains/allowed", AllowedDomain)

    def fetch_blocked_domains(self) -> List[BlockedDomain]:
        return self._fetch_domains("/api/v1/domains/blocked", BlockedDomain)

    def fetch_blocked_categories(self) -> List[BlockedCategory]:
        return self._fetch_domains("/api/v1/categories/blocked", BlockedCategory)

    def _fetch_domains(self, endpoint: str, model_class: Type[BaseModel]) -> List[BaseModel]:
        if not endpoint.startswith('/'):
            raise ValueError("API endpoint must start with '/'")

        try:
            response = requests.get(
                f"{self.base_url}{endpoint}",
                timeout=10,
                headers={'Accept': 'application/json'}
            )
            response.raise_for_status()

            domains_data = response.json()
            if not isinstance(domains_data, list):
                raise ValueError("Expected array response from API")

            return [model_class(**domain) for domain in domains_data]

        except requests.RequestException as e:
            raise requests.RequestException(f"Failed to fetch domains: {str(e)}") from e
        except (KeyError, ValueError) as e:
            raise ValueError(f"Invalid response format from API: {str(e)}") from e

# Example usage:
if __name__ == "__main__":
    service = DomainService()
    try:
        allowed_domains = service.fetch_allowed_domains()
        print("\nAllowed Domains:")
        for domain in allowed_domains:
            status = "active" if domain.is_active else "inactive"
            print(f"- {domain.domain} ({status})")

        blocked_domains = service.fetch_blocked_domains()
        print("\nBlocked Domains:")
        for domain in blocked_domains:
            print(f"- {domain.domain} (Reason: {domain.reason})")

        blocked_categories = service.fetch_blocked_categories()
        print("\nBlocked Categories:")
        for category in blocked_categories:
            print(f"- {category.name} ({category.severity})")
            print(f"  Description: {category.description}")
    except Exception as e:
        print(f"Error: {str(e)}")

================
File: email_scanner_consumer.py
================
import ell
import openai
import json
import logging
import os
import re
import time
import argparse
from kafka import KafkaConsumer
from imapclient import IMAPClient
from email import message_from_bytes
from bs4 import BeautifulSoup

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Email Scanner Consumer")
parser.add_argument("--base-url", default="10.1.1.144:11434", help="Base URL for the OpenAI API")
parser.add_argument("--consumer-group", default="email-scanner-group", help="Kafka consumer group name")
parser.add_argument("--delay-on-error-seconds", default=10, help="Delay on error seconds")
args = parser.parse_args()

ell.init(verbose=False, store='./logdir')

client = openai.Client(
    base_url=f"http://{args.base_url}/v1", api_key="ollama"  # required but not used
)

@ell.simple(model="llama3.2:latest", temperature=0.1, client=client)
def categorize_email_ell_for_me(contents: str):
    """
You are an AI assistant tasked with categorizing incoming emails. Your goal is to efficiently sort emails into predefined categories without being swayed by marketing tactics or sales pitches. You have a strong aversion to unsolicited commercial content and are programmed to prioritize the user's financial well-being by avoiding unnecessary expenditures.

When categorizing emails, you must strictly adhere to the following six categories:

'Personal': Emails from friends, family, or acquaintances that are not related to work or financial matters. This includes personal correspondence, invitations to social events, and general updates from individuals known to the user.
'Financial-Notification': Any email related to the user's financial accounts or transactions. This includes bank statements, credit card alerts, investment updates, payment confirmations, and notifications about account activity or balance changes.
'Appointment-Reminder': Emails that serve as reminders for upcoming appointments, meetings, or events. This category includes doctor's appointments, dental visits, scheduled calls, and any other time-specific commitments.
'Service-Updates': Notifications about changes, updates, or important information from services the user is already subscribed to or uses. This can include updates from software providers, changes to terms of service, account security notifications, and status updates for ongoing services.
'Work-related': Any email pertaining to the user's professional life. This includes correspondence with colleagues, superiors, or clients, project updates, meeting invitations, and any other communication related to the user's job or career.
'Other': This category is for emails that don't clearly fit into the above categories. It may include newsletters the user has willingly subscribed to, community announcements, or any other email that doesn't fall neatly into the other five categories.
Important guidelines:

Approach each email with skepticism towards any content that appears to be trying to sell products or services.
Be particularly wary of emails that encourage spending money, even if they claim to offer deals or discounts.
If an email contains elements of multiple categories, prioritize the most significant or actionable aspect when choosing a category.
Pay close attention to the sender, subject line, and key content to make accurate categorizations.
Remember that the goal is to organize emails efficiently, not to engage with or respond to their content.
By following these guidelines and strictly adhering to the given categories, you will help the user maintain an organized inbox while avoiding unwanted commercial influences.
    """
    return f"Categorize this email. You are limited into one of the categories. Maximum length of response is 2 words: {contents}"

@ell.simple(model="llama3.2:latest", temperature=0.5, client=client)
def categorize_email_ell_marketing(contents: str):
    """
You are an AI assistant designed to categorize incoming emails with a focus on protecting the user from unwanted commercial content and unnecessary spending. Your primary goal is to quickly identify and sort emails that may be attempting to solicit money or promote products/services. You should approach each email with a healthy dose of skepticism, always on the lookout for subtle or overt attempts to encourage spending.
When categorizing emails, you must strictly adhere to the following four categories:

'Wants-Money': This category is for any email that directly or indirectly asks the recipient to spend money. This includes:

Invoices or bills
Requests for donations or charitable contributions
Notifications about due payments or subscriptions
Emails about fundraising campaigns
Messages asking for financial support of any kind
Subtle requests disguised as opportunities that require monetary investment


'Advertising': This category is for emails primarily focused on promoting specific products or services. Look for:

Direct product advertisements
Sale announcements
New product launches
Service offerings
Emails showcasing product features or benefits
Messages with prominent calls-to-action to purchase or "learn more" about products


'Marketing': This category is for emails that may not directly advertise products but are part of broader marketing strategies. This includes:

Brand awareness campaigns
Newsletters with soft-sell approaches
Content marketing emails (blogs, articles, videos) that indirectly promote products or services
Customer relationship emails that don't directly sell but keep the brand in the recipient's mind
Surveys or feedback requests that are part of marketing research
Emails about loyalty programs or rewards


'Other': This category is for all emails that don't fit into the above three categories. This may include:

Personal correspondence
Work-related emails
Transactional emails (e.g., order confirmations, shipping notifications)
Account security alerts
Appointment reminders
Service updates or notifications not aimed at selling



Important guidelines:

Be vigilant in identifying even subtle attempts to encourage spending or promote products/services.
Pay close attention to the sender, subject line, and key content to make accurate categorizations.
If an email contains elements of multiple categories, prioritize 'Wants-Money' first, then 'Advertising', then 'Marketing'.
Remember that the goal is to shield the user from unwanted commercial influences and protect them from unnecessary spending.
Approach each email with the assumption that it may be trying to sell something, and only categorize as 'Other' if you're confident it's not commercial in nature.

By following these guidelines and strictly adhering to the given categories, you will help the user maintain an inbox free from unwanted commercial content and protect them from potential financial solicitations.
"""
    return f"Categorize this email. You are limited into one of the categories. Maximum length of response is 2 words: {contents}"

@ell.simple(model="llama3.2:latest", temperature=0.5, client=client)
def categorize_email_ell_generic(contents: str):
    """
Email Intent Analyzer:
You are an AI designed to swiftly discern and label the core intention behind each email. Your task is to deduce the primary purpose of the email's author, with a particular focus on identifying attempts to seek money, advertise products/services, or gain political influence.
Your responses must always be two words or fewer. Be concise yet precise.
Key objectives:

Quickly assess the email's content, sender, and context.
Determine the author's main goal or intention.
Categorize using clear, succinct labels.

Primary categories to consider (not exhaustive):

"Seeks Money" (or variations like "Requests Donation", "Demands Payment")
"Promotes Product" or "Advertises Service"
"Political Appeal" or "Seeks Support"
"Shares Information"
"Requests Action"
"Personal Message"

Guidelines:

Prioritize identifying commercial or political motivations.
Look for subtle cues that might reveal hidden intentions.
If multiple purposes are present, identify the most prominent one.
Use active verbs when possible to convey intent (e.g., "Solicits Funds" rather than "Fundraising Email").
Remain objective and avoid emotional language.

Examples:

For an email asking for donations: "Seeks Donation"
For a marketing newsletter: "Promotes Products"
For a political campaign email: "Political Persuasion"
For a personal message from a friend: "Personal Correspondence"

Remember: Your labels must be two words or fewer, clear, and accurately reflect the email author's primary intention.
"""
    return f"Categorize this email. Maximum length of response is 2 words: {contents}"


ok = [
        'Personal', 
        'Financial-Notification', 
        'Appointment-Reminder', 
        'Service-Updates', 
        'Work-related',
        "order", 
        "order cancelled", 
        "order confirm", 
        "order confirmed", 
        "order confirmation", 
        "order placed", 
        "order promised", 
        "order reminder", 
        "order scheduled", 
        "order update", 
        "order shipped", 
        "personal", 
        "statement", 
        "bank", 
        "alert", 
        "legal", 
        "legalese", 
        "document", 
        "memorandum", 
        "appointment confirmation", 
        "appointment confirmed", 
        "appointment reminder", 
        "appointment scheduled", 
        "correspondance",
        "\"alert\"", 
        "\"bank\"", 
        "\"personal\""
    ]

def get_imap_client():
    # Replace with your Gmail IMAP settings
    IMAP_HOST = 'imap.gmail.com'
    IMAP_PORT = 993
    EMAIL = os.environ.get('GMAIL_EMAIL')
    PASSWORD = os.environ.get('GMAIL_PASSWORD')

    if not EMAIL or not PASSWORD:
        raise ValueError("Please set GMAIL_EMAIL and GMAIL_PASSWORD environment variables")

    logger.info(f"Logging in with username: {EMAIL}")
    logger.info(f"Password length: {len(PASSWORD)}")

    # Encode EMAIL and PASSWORD to ASCII, replacing non-ASCII characters
    EMAIL_encoded = EMAIL.encode('ascii', 'ignore').decode('ascii')
    PASSWORD_encoded = PASSWORD.encode('ascii', 'ignore').decode('ascii')

    logger.info("Connecting to Gmail IMAP server...")
    client = IMAPClient(IMAP_HOST, port=IMAP_PORT, use_uid=True, ssl=True)
    client.login(EMAIL_encoded, PASSWORD_encoded)
    logger.info("Successfully connected to Gmail IMAP server")
    return client

def capitalize_words(text):
    return ' '.join(word.capitalize() for word in text.split())


def get_sender_email(email_message):
    sender = email_message['From']
    if isinstance(sender, str):
        if '<' in sender:
            return sender.split('<')[1].split('>')[0]
        return sender
    elif hasattr(sender, 'addresses'):
        # Handle email.header.Header object
        return str(sender.addresses[0].addr_spec)
    else:
        # Fallback: convert to string
        return str(sender)
    
def set_email_label(client, msg_id, label):
    if label.lower() == "spam":
        label = "Junk"
    # Remove surrounding quotes if present
    label = label.strip("\"'")
    # Capitalize each word in the label
    label = capitalize_words(label)
    logger.info(f"Setting label '{label}' for email {msg_id}")
    try:
        client.add_gmail_labels(msg_id, [label])
    except Exception as e:
        logger.error(f"Error setting label or removing Inbox label: {e}")

def extract_html_content(html_content):
    soup = BeautifulSoup(html_content, 'html.parser')
    return soup.get_text(separator=' ', strip=True)

def get_email_body(email_message):
    body = ''
    if email_message.is_multipart():
        for part in email_message.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                body = part.get_payload(decode=True).decode(errors='ignore')
                break
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(errors='ignore')
                body = extract_html_content(html_content)
                break
    else:
        content_type = email_message.get_content_type()
        if content_type == "text/plain":
            body = email_message.get_payload(decode=True).decode(errors='ignore')
        elif content_type == "text/html":
            html_content = email_message.get_payload(decode=True).decode(errors='ignore')
            body = extract_html_content(html_content)
    return body

def remove_http_links(text):
    # Regular expression pattern to match HTTP links
    pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
    
    # Replace all occurrences of the pattern with an empty string
    cleaned_text = re.sub(pattern, '', text)
    
    return cleaned_text

def remove_encoded_content(text):
    # Regular expression pattern to match the encoded content format
    pattern = r'\(\s*~~/[A-Za-z0-9/+]+~\s*\)'
    
    # Replace all occurrences of the pattern with an empty string
    cleaned_text = re.sub(pattern, '', text)
    
    return cleaned_text

def remove_images_from_email(email_body):
    """
    Remove images from email contents.
    
    Args:
    email_body (str): The email body content (can be HTML or plain text).
    
    Returns:
    str: Email body with images removed.
    """
    # Check if the email body is HTML
    if re.search(r'<[^>]+>', email_body):
        # Parse HTML content
        soup = BeautifulSoup(email_body, 'html.parser')
        
        # Remove all img tags
        for img in soup.find_all('img'):
            img.decompose()
        
        # Remove all elements with background images
        for element in soup.find_all(style=re.compile('background-image')):
            del element['style']
        
        # Convert back to string
        return str(soup)
    else:
        # For plain text, remove any text that looks like an image file or URL
        return re.sub(r'\b(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|bmp))\b', '', email_body, flags=re.IGNORECASE)

def mark_email_as_unread(client, msg_id):
    logger.info(f"Marking email {msg_id} as unread")
    try:
        client.remove_flags([msg_id], [b'\\Seen'])
        logger.info(f"Email {msg_id} marked as unread successfully")
    except Exception as e:
        logger.error(f"Error marking email {msg_id} as unread: {e}")

def delete_and_expunge_email(client, msg_id):
    logger.info(f"Deleting and expunging email {msg_id}")
    try:
        client.delete_messages([msg_id])
        client.expunge()
        logger.info(f"Email {msg_id} deleted and expunged successfully")
    except Exception as e:
        logger.error(f"Error deleting and expunging email {msg_id}: {e}")

def process_email(client, msg_id, category_counter=None):
    fetch_data = client.fetch([msg_id], ['INTERNALDATE', 'RFC822', 'FLAGS', 'X-GM-LABELS'])
    email_data = fetch_data[msg_id][b'RFC822']
    email_message = message_from_bytes(email_data)
    existing_email_labels = fetch_data[msg_id][b'X-GM-LABELS']
    
    subject = email_message['Subject']
    sender = get_sender_email(email_message)
    timestamp = fetch_data[msg_id][b'INTERNALDATE']
    body = get_email_body(email_message)
    contents_without_links = remove_http_links(f"{subject}. {body}")
    contents_without_images = remove_images_from_email(contents_without_links)
    contents_without_encoded = remove_encoded_content(contents_without_images)
    contents_cleaned = contents_without_encoded

    ignore_existing_labels = True
    
    if not ignore_existing_labels:
        if existing_email_labels is not None and len(existing_email_labels) > 0:
            if len(existing_email_labels) == 1 and existing_email_labels[0] == b'\\Important':
                pass
            else:
                logger.info(f"Email - {msg_id} has labels {existing_email_labels}. Skipping...")
                logger.info("---")
                return existing_email_labels
    
    category = categorize_email_ell_for_me(contents_cleaned)
    category = category.replace('"', '').replace("'", "").replace('*', '').replace('=', '').replace('+', '').replace('-', '').replace('_', '')
    category_lower = category.lower()
    
    logger.info("************")
    logger.info(f"Email - Timestamp: {timestamp}")
    logger.info(f"Email - Sender: {sender}")
    logger.info(f"Email - Subject: {subject}")
    if category_lower != "other" and len(category_lower) > 4 and category_lower in ok:
        set_email_label(client, msg_id, category)
        mark_email_as_unread(client, msg_id)
        logger.info("Email - Email is meant for me")
        logger.info("************")
    else:
        category = categorize_email_ell_marketing(contents_cleaned)
        category = category.replace('"', '').replace("'", "")
        category_lower = category.lower()
        if category_lower != "other" and len(category_lower) > 4 and len(category_lower) <= 40:
            set_email_label(client, msg_id, category)
            delete_and_expunge_email(client, msg_id)
            logger.info("Email - Email is an advertisement")
        else:
            category = categorize_email_ell_generic(contents_cleaned)
            category = category.replace('"', '').replace("'", "")
            if len(category) > 4 and len(category) < 40:
                set_email_label(client, msg_id, category)
                delete_and_expunge_email(client, msg_id)
                logger.info("Email - Email is generic")
            else:
                logger.info(f"Email - Could not categorize email {msg_id}. Skipping... ***")
    logger.info("************")

    if category_counter is not None:
        category_counter[category] += 1

    logger.info(f"Email - Category: {category}")
    logger.info("---")
    
    return category

def listen_to_kafka_topic(topic: str = 'gmail_messages', bootstrap_servers: str = 'localhost:9092', consumer_group: str = 'email-scanner-group', delay_on_error_seconds: str = '10'):
    """
    Listen to a Kafka topic and print incoming messages.
    
    :param topic: The Kafka topic to listen to (default: 'gmail_messages')
    :param bootstrap_servers: The Kafka server address (default: 'localhost:9092')
    """
    consumer = KafkaConsumer(
        topic,
        bootstrap_servers=[bootstrap_servers],
        group_id=consumer_group,
        auto_offset_reset='latest',
        enable_auto_commit=True,
        value_deserializer=lambda x: json.loads(x.decode('utf-8'))
    )

    client = get_imap_client()    
    client.select_folder('INBOX')
    
    logger.info(f"Starting to listen to Kafka topic: {topic}")
    
    try:
        for message in consumer:
            logger.info(f"Received message from partition {message.partition}, offset {message.offset}:")
            msg_id = message.value['msg_id']
            logger.info(f"Message ID: {msg_id}")
            try:
                process_email(client, msg_id)
            except Exception as e:
                logger.error(f"Error categorizing email: {e}")
                client = get_imap_client()    
                client.select_folder('INBOX')
                delay = int(delay_on_error_seconds)
                logger.info(f"Sleeping for {delay} seconds because of above error")
                time.sleep(delay)

            logger.info("-" * 50)
    
    except KeyboardInterrupt:
        logger.info("Listener stopped by user.")
    finally:
        consumer.close()
        client.logout()
        logger.info("Kafka consumer closed.")

if __name__ == "__main__":
    topic = 'gmail_messages'
    listen_to_kafka_topic(topic=topic, bootstrap_servers="localhost:9092", consumer_group=args.consumer_group, delay_on_error_seconds=args.delay_on_error_seconds)

================
File: email_scanner_producer.py
================
import os
import argparse
import logging
from email.header import decode_header
from collections import Counter
from datetime import datetime, timedelta
from imapclient import IMAPClient
from email import message_from_bytes
from bs4 import BeautifulSoup
from anthropic import Anthropic
from send_email_to_kafka import send_email_to_kafka

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

ok = [
        'Personal', 
        'Financial-Notification', 
        'Appointment-Reminder', 
        'Service-Updates', 
        'Work-related',
        "order", 
        "order cancelled", 
        "order confirm", 
        "order confirmed", 
        "order confirmation", 
        "order placed", 
        "order promised", 
        "order reminder", 
        "order scheduled", 
        "order update", 
        "order shipped", 
        "personal", 
        "statement", 
        "bank", 
        "alert", 
        "legal", 
        "legalese", 
        "document", 
        "memorandum", 
        "appointment confirmation", 
        "appointment confirmed", 
        "appointment reminder", 
        "appointment scheduled", 
        "correspondance",
        "\"alert\"", 
        "\"bank\"", 
        "\"personal\""
    ]


def get_imap_client():
    # Replace with your Gmail IMAP settings
    IMAP_HOST = 'imap.gmail.com'
    IMAP_PORT = 993
    EMAIL = os.environ.get('GMAIL_EMAIL')
    PASSWORD = os.environ.get('GMAIL_PASSWORD')

    if not EMAIL or not PASSWORD:
        raise ValueError("Please set GMAIL_EMAIL and GMAIL_PASSWORD environment variables")

    logger.info(f"Logging in with username: {EMAIL}")
    logger.info(f"Password length: {len(PASSWORD)}")

    # Encode EMAIL and PASSWORD to ASCII, replacing non-ASCII characters
    EMAIL_encoded = EMAIL.encode('ascii', 'ignore').decode('ascii')
    PASSWORD_encoded = PASSWORD.encode('ascii', 'ignore').decode('ascii')

    logger.info("Connecting to Gmail IMAP server...")
    client = IMAPClient(IMAP_HOST, port=IMAP_PORT, use_uid=True, ssl=True)
    client.login(EMAIL_encoded, PASSWORD_encoded)
    logger.info("Successfully connected to Gmail IMAP server")
    return client

def get_recent_emails(client, hours):
    logger.info("Selecting INBOX folder...")
    client.select_folder('INBOX')
    time_ago = datetime.now() - timedelta(hours=hours)
    date_criterion = time_ago.strftime("%d-%b-%Y")
    logger.info(f"Searching for emails since {date_criterion}...")
    messages = client.search(['SINCE', date_criterion, 'NOT', 'KEYWORD', 'bogus-asdf'])
    logger.info(f"Found {len(messages)} recent emails")
    
    total_messages = len(messages)
    for index, msg_id in enumerate(messages, 1):
        logger.info(f"Processing {index} of {total_messages} emails, ID: {msg_id}")
        try:
            send_email_to_kafka(msg_id)
        except Exception as e:
            logger.info(f"Problem fetching recent email [{msg_id}]: {e}")
    
    logger.info("Emails sorted by timestamp in descending order")
    return None

from datetime import datetime

# The expected format for the date? dd-MMM-yyyy
def get_emails_by_date_range(start_date_str, end_date_str):
    """
    Fetch email message IDs within a specified date range.

    :param start_date_str: Start date (inclusive) as a string in format "dd-MMM-yyyy"
    :param end_date_str: End date (inclusive) as a string in format "dd-MMM-yyyy"
    :return: List of message IDs
    """
    client = get_imap_client()    
    logger.info("Selecting INBOX folder...")
    client.select_folder('INBOX')

    start_date = datetime.strptime(start_date_str, "%d-%b-%Y")
    end_date = datetime.strptime(end_date_str, "%d-%b-%Y")

    start_criterion = start_date.strftime("%d-%b-%Y")
    end_criterion = end_date.strftime("%d-%b-%Y")
    
    logger.info(f"Searching for emails between {start_criterion} and {end_criterion}...")
    messages = client.search(['SINCE', start_criterion, 'BEFORE', end_criterion, 'NOT', 'KEYWORD', 'bogus-asdf'])
    
    total_messages = len(messages)
    logger.info(f"Found {total_messages} emails within the specified date range")
    for index, msg_id in enumerate(messages, 1):
        logger.info(f"Processing {index} of {total_messages} emails, ID: {msg_id}")
        try:
            send_email_to_kafka(msg_id)
        except Exception as e:
            logger.info(f"Problem fetching recent email [{msg_id}]: {e}")

    return messages


def send_recent_emails_to_kafka(hours):
    client = get_imap_client()    
    client.select_folder('INBOX')
    time_ago = datetime.now() - timedelta(hours=hours)
    get_recent_emails(client, hours)


def main():
    logger.info("Starting Gmail Categorizer")
    parser = argparse.ArgumentParser(description="Gmail Categorizer using Ollama or Anthropic API")
    parser.add_argument("--hours", type=int, default=1, help="Number of hours to look back for emails")
    parser.add_argument("--start", help="Start date")
    parser.add_argument("--end", help="End date")
    args = parser.parse_args()

    hours = args.hours
    start = args.start
    end = args.end
    
    # validate start and end are in format dd-MMM-yyyy
    if start:
        try:
            datetime.strptime(start, "%d-%b-%Y")
        except ValueError:
            logger.error("Invalid start date format. Expected format: dd-MMM-yyyy. Example: 01-Jan-2021")
            return
    if end:
        try:
            datetime.strptime(end, "%d-%b-%Y")
        except ValueError:
            logger.error("Invalid end date format. Expected format: dd-MMM-yyyy. Example: 01-Jan-2021")
            return

    if hours > 0:
        logger.info(f"Fetching emails from the last {hours} hour(s)")
        send_recent_emails_to_kafka(hours)

    if start != "" and end != "":
        logger.info(f"Fetching emails from {start} to {end}")
        get_emails_by_date_range(start, end)

    logger.info("Gmail Categorizer finished")

if __name__ == '__main__':
    main()

================
File: gmail_fetcher.py
================
import argparse
import ell
import openai
import os
import imaplib
from email import message_from_bytes  # Changed import
from datetime import datetime, timedelta, timezone
from email.utils import parsedate_to_datetime
from typing import List, Optional
from bs4 import BeautifulSoup
import re
from collections import Counter
from tabulate import tabulate

parser = argparse.ArgumentParser(description="Email Fetcher")
parser.add_argument("--base-url", default="10.1.1.144:11434", help="Base URL for the OpenAI API")
parser.add_argument("--hours", type=int, default=2, help="The hours to fetch emails")
args = parser.parse_args()

ell.init(verbose=False, store='./logdir')

client = openai.Client(
    base_url=f"http://{args.base_url}/v1", api_key="ollama"  # required but not used
)

allowed_domains = [
    "github.com",
    "amazon.com",
    "apple.com",
    "google.com",
    "microsoft.com",
    "microcenter.com",
    "americanexpress.com",
    "citi.com",
    "wellsfargo.com",
    "chase.com",
    "discover.com",
    "capitalone.com",
    "delta.com",
    "united.com",
    "southwest.com",
    "jetblue.com",
    "americanairlines.com",
    "masterclass.com",
    "instacart.com",
    "zbarleungcpa.com",
    "intuit.com",
    "patreon.com",
    "summarize.ing",
    "justride.com",
    "codescene.com",
    "theburningmonk.com",
    "accounts.google.com",
    "elevenlabs.io",
    "thriftytraveler.com",
    "optery.com",
    "deleteme.com",
    "incogni.com",
    "gamma.app",
    "novita.ai",
    "deadmansnitch.com",
    "localstack.cloud",
    "jpmorgan.com",
]

blocked_domains = [
    "facebook.com",
    "daveandbusters.com",
    "rh.com",
    "raymourflanigan.com",
]

allowed_categories = [
    "Wants-Money",
    "Advertising",
    "Marketing",
    "Promotional",
]

@ell.simple(model="llama3.2:latest", temperature=0.1, client=client)
def categorize_email_ell_marketing(contents: str):
    """
You are an AI assistant designed to categorize incoming emails with a focus on protecting the user from unwanted commercial content and unnecessary spending. Your primary goal is to quickly identify and sort emails that may be attempting to solicit money or promote products/services. You should approach each email with a healthy dose of skepticism, always on the lookout for subtle or overt attempts to encourage spending.
When categorizing emails, you must strictly adhere to the following four categories:

'Wants-Money': This category is for any email that directly or indirectly asks the recipient to spend money. This includes:

Invoices or bills
Requests for donations or charitable contributions
Notifications about due payments or subscriptions
Emails about fundraising campaigns
Messages asking for financial support of any kind
Subtle requests disguised as opportunities that require monetary investment


'Advertising': This category is for emails primarily focused on promoting specific products or services. Look for:

Direct product advertisements
Sale announcements
New product launches
Service offerings
Emails showcasing product features or benefits
Messages with prominent calls-to-action to purchase or "learn more" about products


'Marketing': This category is for emails that may not directly advertise products but are part of broader marketing strategies. This includes:

Brand awareness campaigns
Newsletters with soft-sell approaches
Content marketing emails (blogs, articles, videos) that indirectly promote products or services
Customer relationship emails that don't directly sell but keep the brand in the recipient's mind
Surveys or feedback requests that are part of marketing research
Emails about loyalty programs or rewards


'Other': This category is for all emails that don't fit into the above three categories. This may include:

Personal correspondence
Work-related emails
Transactional emails (e.g., order confirmations, shipping notifications)
Account security alerts
Appointment reminders
Service updates or notifications not aimed at selling



Important guidelines:

Be vigilant in identifying even subtle attempts to encourage spending or promote products/services.
Pay close attention to the sender, subject line, and key content to make accurate categorizations.
If an email contains elements of multiple categories, prioritize 'Wants-Money' first, then 'Advertising', then 'Marketing'.
Remember that the goal is to shield the user from unwanted commercial influences and protect them from unnecessary spending.
Approach each email with the assumption that it may be trying to sell something, and only categorize as 'Other' if you're confident it's not commercial in nature.

By following these guidelines and strictly adhering to the given categories, you will help the user maintain an inbox free from unwanted commercial content and protect them from potential financial solicitations.
"""
    return f"Categorize this email. You are limited into one of the categories. Maximum length of response is 2 words: {contents}"

class GmailFetcher:
    def __init__(self, email_address: str, app_password: str):
        """
        Initialize Gmail connection using IMAP.
        
        Args:
            email_address: Gmail address
            app_password: Gmail App Password (NOT your regular Gmail password)
        """
        self.email_address = email_address
        self.password = app_password
        self.imap_server = "imap.gmail.com"
        self.conn = None
        self.stats = {
            'deleted': 0,
            'kept': 0,
            'categories': Counter()
        }

    def connect(self) -> None:
        """Establish connection to Gmail IMAP server."""
        try:
            self.conn = imaplib.IMAP4_SSL(self.imap_server)
            self.conn.login(self.email_address, self.password)
        except Exception as e:
            raise Exception(f"Failed to connect to Gmail: {str(e)}")

    def disconnect(self) -> None:
        """Close the IMAP connection."""
        if self.conn:
            self.conn.logout()

    def _create_email_message(self, msg_data) -> Optional[message_from_bytes]:
        """Convert raw message data into an email message object."""
        if not msg_data or not msg_data[0]:
            return None
        email_body = msg_data[0][1]
        return message_from_bytes(email_body)

    def _is_email_within_threshold(self, email_message, date_threshold) -> bool:
        """Check if email falls within the specified time threshold."""
        date_tuple = email_message.get("Date")
        if not date_tuple:
            return False
        email_date = parsedate_to_datetime(date_tuple)
        if date_threshold.tzinfo is None:
            date_threshold = date_threshold.replace(tzinfo=timezone.utc)
        if email_date.tzinfo is None:
            email_date = email_date.replace(tzinfo=timezone.utc)
        return email_date > date_threshold

    def capitalize_words(self, text):
        return ' '.join(word.capitalize() for word in text.split())

    def remove_http_links(self, text):
        # Regular expression pattern to match HTTP links
        pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
        
        # Replace all occurrences of the pattern with an empty string
        cleaned_text = re.sub(pattern, '', text)
        
        return cleaned_text

    def remove_encoded_content(self, text):
        # Regular expression pattern to match the encoded content format
        pattern = r'\(\s*~~/[A-Za-z0-9/+]+~\s*\)'
        
        # Replace all occurrences of the pattern with an empty string
        cleaned_text = re.sub(pattern, '', text)
        
        return cleaned_text

    def remove_images_from_email(self, email_body):
        """
        Remove images from email contents.
        
        Args:
        email_body (str): The email body content (can be HTML or plain text).
        
        Returns:
        str: Email body with images removed.
        """
        # Check if the email body is HTML
        if re.search(r'<[^>]+>', email_body):
            # Parse HTML content
            soup = BeautifulSoup(email_body, 'html.parser')
            
            # Remove all img tags
            for img in soup.find_all('img'):
                img.decompose()
            
            # Remove all elements with background images
            for element in soup.find_all(style=re.compile('background-image')):
                del element['style']
            
            # Convert back to string
            return str(soup)
        else:
            # For plain text, remove any text that looks like an image file or URL
            return re.sub(r'\b(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|bmp))\b', '', email_body, flags=re.IGNORECASE)

    def add_label(self, message_id: str, label: str) -> bool:
        """
        Add a label to a message without marking it as read.
        
        Args:
            message_id: The message ID to label
            label: The Gmail label to add
            
        Returns:
            bool: True if successful, False otherwise
        """
        if not self.conn:
            raise Exception("Not connected to Gmail")

        try:
            # Search for the message ID to get the sequence number
            _, data = self.conn.search(None, f'(HEADER Message-ID "{message_id}")')
            if not data[0]:
                print(f"Message ID {message_id} not found")
                return False

            sequence_number = data[0].split()[0]
            
            # Create the label if it doesn't exist
            self.conn.create(f'"{label}"')
            
            # Copy the message to the label
            result = self.conn.copy(sequence_number, f'"{label}"')
            return result[0] == 'OK'
        except Exception as e:
            print(f"Error adding label: {str(e)}")
            return False

    def get_email_body(self, email_message) -> str:
        """
        Extract the body content from an email message.
        Handles both plain text and HTML emails.
        
        Args:
            email_message: Email message object
            
        Returns:
            str: The email body content
        """
        body = ""
        
        if email_message.is_multipart():
            # Handle multipart messages
            for part in email_message.walk():
                content_type = part.get_content_type()
                content_disposition = str(part.get("Content-Disposition"))

                # Skip attachments
                if "attachment" in content_disposition:
                    continue

                if content_type == "text/plain":
                    try:
                        body = part.get_payload(decode=True).decode()
                        break
                    except:
                        continue
                elif content_type == "text/html":
                    try:
                        html_content = part.get_payload(decode=True).decode()
                        # Convert HTML to plain text
                        soup = BeautifulSoup(html_content, 'html.parser')
                        body = soup.get_text(separator=' ', strip=True)
                        break
                    except:
                        continue
        else:
            # Handle non-multipart messages
            content_type = email_message.get_content_type()
            try:
                if content_type == "text/plain":
                    body = email_message.get_payload(decode=True).decode()
                elif content_type == "text/html":
                    html_content = email_message.get_payload(decode=True).decode()
                    soup = BeautifulSoup(html_content, 'html.parser')
                    body = soup.get_text(separator=' ', strip=True)
            except:
                body = "Could not decode email content"

        # Clean up the body text
        body = re.sub(r'\s+', ' ', body).strip()  # Remove extra whitespace
        return body

    def get_recent_emails(self, hours: int = 2) -> List[message_from_bytes]:
        """
        Fetch emails from the last specified hours.
        """
        if not self.conn:
            raise Exception("Not connected to Gmail")

        # Select inbox
        self.conn.select("INBOX")

        # Calculate the date threshold with timezone information
        date_threshold = datetime.now(timezone.utc) - timedelta(hours=hours)
        date_str = date_threshold.strftime("%d-%b-%Y")

        # Search for emails after the threshold
        search_criteria = f'(SINCE "{date_str}")'
        _, message_numbers = self.conn.search(None, search_criteria)

        emails = []
        for num in message_numbers[0].split():
            fetch_command = "(BODY.PEEK[])"
            _, msg_data = self.conn.fetch(num, fetch_command)
            
            email_message = self._create_email_message(msg_data)
            if not email_message:
                continue
                
            if self._is_email_within_threshold(email_message, date_threshold):
                emails.append(email_message)

        return emails

    def delete_email(self, message_id: str) -> bool:
        """
        Delete an email by moving it to the Trash folder.
        
        Args:
            message_id: The Message-ID of the email to delete
            
        Returns:
            bool: True if successful, False otherwise
        """
        if not self.conn:
            raise Exception("Not connected to Gmail")

        try:
            # Search for the message ID to get the sequence number
            _, data = self.conn.search(None, f'(HEADER Message-ID "{message_id}")')
            if not data[0]:
                print(f"Message ID {message_id} not found")
                return False

            sequence_number = data[0].split()[0]
            
            # Move to Trash (Gmail's trash folder is [Gmail]/Trash)
            self.conn.store(sequence_number, '+FLAGS', '\\Deleted')
            result = self.conn.copy(sequence_number, '[Gmail]/Trash')
            
            if result[0] == 'OK':
                # Expunge the original message
                self.conn.expunge()
                self.stats['deleted'] += 1  # Increment delete counter
                return True
            return False
            
        except Exception as e:
            print(f"Error deleting email: {str(e)}")
            return False

def print_summary(hours: int, stats: dict):
    """Print a summary of email processing results."""
    print("\n" + "="*50)
    print("SUMMARY")
    print("="*50)
    print(f"Time window: Last {hours} hours")
    print(f"Emails processed: {stats['deleted'] + stats['kept']}")
    print(f"Emails deleted: {stats['deleted']}")
    print(f"Emails kept: {stats['kept']}")
    
    # Create category table
    if stats['categories']:
        print("\nCategories:")
        table = [[category, count] for category, count in stats['categories'].most_common()]
        print(tabulate(table, headers=['Category', 'Count'], tablefmt='grid'))
    print("="*50 + "\n")

def main(email_address: str, app_password: str, hours: int = 2):
    # Initialize and use the fetcher
    fetcher = GmailFetcher(email_address, app_password)
    try:
        fetcher.connect()
        recent_emails = fetcher.get_recent_emails(hours)
        
        print(f"Found {len(recent_emails)} emails in the last {hours} hours:")
        for msg in recent_emails:
            # Get the email body
            body = fetcher.get_email_body(msg)
            pre_categorized = False
            deletion_candidate = True
            
            # iterate over the blocked domains
            from_header = str(msg.get('From', ''))
            for domain in blocked_domains:
                if domain in from_header:
                    category = "Blocked_Domain"
                    pre_categorized = True
                    deletion_candidate = True
                    break
            
            # iterate over the allowed domains
            for domain in allowed_domains:
                if domain in from_header:
                    category = "Allowed_Domain"
                    pre_categorized = True
                    deletion_candidate = False
                    break
            
            # categorize the email
            if not pre_categorized:
                contents_without_links = fetcher.remove_http_links(f"{msg.get('Subject')}. {body}")
                contents_without_images = fetcher.remove_images_from_email(contents_without_links)
                contents_without_encoded = fetcher.remove_encoded_content(contents_without_images)
                contents_cleaned = contents_without_encoded
                category = categorize_email_ell_marketing(contents_cleaned)
                category = category.replace('"', '').replace("'", "").replace('*', '').replace('=', '').replace('+', '').replace('-', '').replace('_', '')
                
                if category in allowed_categories:
                    deletion_candidate = True

            print(f"From: {msg.get('From')}")
            print(f"Subject: {msg.get('Subject')}")
            if len(category) < 20:
                print(f"Category: {category}")
            print(f"Deletion Candidate: {deletion_candidate}")
            fetcher.add_label(msg.get("Message-ID"), category)
            
            # Track categories
            fetcher.stats['categories'][category] += 1
            
            # Track kept/deleted emails
            if deletion_candidate:
                if fetcher.delete_email(msg.get("Message-ID")):
                    print("Email deleted successfully")
                else:
                    print("Failed to delete email")
                    fetcher.stats['kept'] += 1
            else:
                print("Email left in inbox")
                fetcher.stats['kept'] += 1
                    
            print("-" * 50)
            
        # Print summary at the end
        print_summary(hours, fetcher.stats)
            
    finally:
        fetcher.disconnect()

if __name__ == "__main__":
    # Get credentials from environment variables
    email_address = os.getenv("GMAIL_EMAIL")
    app_password = os.getenv("GMAIL_PASSWORD")

    if not email_address or not app_password:
        raise ValueError("Please set GMAIL_EMAIL and GMAIL_PASSWORD environment variables")

    main(email_address, app_password, args.hours)

================
File: Makefile
================
.PHONY: build run clean test

# Docker image name
IMAGE_NAME = gmail-cleaner
TEST_IMAGE_NAME = gmail-cleaner-test

# Build the Docker image
build:
	docker build -t $(IMAGE_NAME) .

# Build the test Docker image
build-test:
	docker build -t $(TEST_IMAGE_NAME) -f Dockerfile.test .

# Run the container with environment variables
run:
	docker run --rm \
		-e GMAIL_EMAIL="$(GMAIL_EMAIL)" \
		-e GMAIL_PASSWORD="$(GMAIL_PASSWORD)" \
		$(IMAGE_NAME) \
		--hours $(or $(HOURS),2)

# Run the tests in Docker
test: build-test
	docker run --rm $(TEST_IMAGE_NAME)

# Clean up Docker images
clean:
	docker rmi $(IMAGE_NAME) $(TEST_IMAGE_NAME)

# Build and run in one command
all: build run

================
File: README.md
================
# Gmail Categorizer

This Python script logs into a Gmail account using IMAP, scans emails from the last 24 hours, and categorizes them based on their content. It can be run locally or within a Docker container.

## Setup and Usage

### Local Setup

1. Set up environment variables:
   - Set `GMAIL_EMAIL` to your Gmail email address
   - Set `GMAIL_PASSWORD` to your Gmail password or an app-specific password

   You can set these variables in your shell:
   ```
   export GMAIL_EMAIL=your.email@gmail.com
   export GMAIL_PASSWORD=your_password_or_app_specific_password
   ```

2. Set up the project:
   ```
   make setup
   ```
   This will install the required packages.

3. Run the script:
   ```
   make run
   ```
   or simply:
   ```
   make
   ```

   You can specify a custom Ollama host using the `--ollama-host` argument:
   ```
   python gmail_categorizer.py --ollama-host http://custom-ollama-host:11343
   ```

### Docker Setup

1. Copy the `.env.example` file to `.env` in the project root:
   ```
   cp .env.example .env
   ```
   Then edit the `.env` file with your actual Gmail credentials:
   ```
   GMAIL_EMAIL=your.email@gmail.com
   GMAIL_PASSWORD=your_password_or_app_specific_password
   ```

2. Build the Docker image:
   ```
   make build
   ```

3. Run the script in a Docker container:
   ```
   make docker-run
   ```

## Categories

The script currently categorizes emails into the following categories:
- Order Receipt
- Advertisement
- Personal Response
- Other

You can modify the `categorize_email` function in `gmail_categorizer.py` to add or change categories as needed.

## Note

This script requires access to your Gmail account. Make sure to review the code and understand what it does before running it with your personal account. If you're using 2-factor authentication, you'll need to create an app-specific password for this script.

## Security Considerations

- Never share your Gmail password or app-specific password with others.
- Be cautious when setting environment variables, especially on shared systems.
- Consider using OAuth2 for more secure authentication in a production environment.
- When using Docker, ensure that your `.env` file is not committed to version control.

================
File: requirements.txt
================
imapclient==2.3.1
requests==2.32.2
beautifulsoup4>=4.12.0
openai>=1.3.0
python-dateutil>=2.8.2
pydantic==2.9.2
kafka-python
tabulate>=0.9.0
requests-mock>=1.11.0

================
File: send_email_to_kafka.py
================
import json
import logging
import os
from bs4 import BeautifulSoup
from imapclient import IMAPClient
from kafka import KafkaProducer

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def get_imap_client():
    # Replace with your Gmail IMAP settings
    IMAP_HOST = 'imap.gmail.com'
    IMAP_PORT = 993
    EMAIL = os.environ.get('GMAIL_EMAIL')
    PASSWORD = os.environ.get('GMAIL_PASSWORD')

    if not EMAIL or not PASSWORD:
        raise ValueError("Please set GMAIL_EMAIL and GMAIL_PASSWORD environment variables")

    logger.info(f"Logging in with username: {EMAIL}")
    logger.info(f"Password length: {len(PASSWORD)}")

    # Encode EMAIL and PASSWORD to ASCII, replacing non-ASCII characters
    EMAIL_encoded = EMAIL.encode('ascii', 'ignore').decode('ascii')
    PASSWORD_encoded = PASSWORD.encode('ascii', 'ignore').decode('ascii')

    logger.info("Connecting to Gmail IMAP server...")
    client = IMAPClient(IMAP_HOST, port=IMAP_PORT, use_uid=True, ssl=True)
    client.login(EMAIL_encoded, PASSWORD_encoded)
    logger.info("Successfully connected to Gmail IMAP server")
    return client


def extract_html_content(html_content):
    soup = BeautifulSoup(html_content, 'html.parser')
    return soup.get_text(separator=' ', strip=True)


def get_email_body(email_message):
    body = ''
    if email_message.is_multipart():
        for part in email_message.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                body = part.get_payload(decode=True).decode(errors='ignore')
                break
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(errors='ignore')
                body = extract_html_content(html_content)
                break
    else:
        content_type = email_message.get_content_type()
        if content_type == "text/plain":
            body = email_message.get_payload(decode=True).decode(errors='ignore')
        elif content_type == "text/html":
            html_content = email_message.get_payload(decode=True).decode(errors='ignore')
            body = extract_html_content(html_content)
    return body



def send_email_to_kafka(msg_id: str, kafka_topic: str = 'gmail_messages', kafka_server: str = 'localhost:9092'):
    """
    Fetch a Gmail message by its ID and send it to a Kafka topic.
    
    :param msg_id: The Gmail message ID
    :param kafka_topic: The Kafka topic to send the message to (default: 'gmail_messages')
    :param kafka_server: The Kafka server address (default: 'localhost:9111')
    """
    # Initialize Kafka producer
    producer = KafkaProducer(
        bootstrap_servers=[kafka_server],
        value_serializer=lambda v: json.dumps(v).encode('utf-8')
    )
    
    has_message_published = False
    
    try:
        # Prepare the message for Kafka
        kafka_message = {
            'msg_id': msg_id,
        }
        
        # Send the message to Kafkagmail
        logger.info("Publishing to Kafka")
        future = producer.send(kafka_topic, value=kafka_message)
        record_metadata = future.get(timeout=10)
        
        logger.info(f"Message sent to Kafka topic {record_metadata.topic} partition {record_metadata.partition} offset {record_metadata.offset}")
        has_message_published = True
    except Exception as e:
        logger.info(f"Error sending message to Kafka: {str(e)}")
    
    finally:
        producer.close()
        
    if not has_message_published:
        raise Exception(f"Failed to publish message {msg_id} to Kafka")

================
File: setup.py
================
from setuptools import setup, find_packages

setup(
    name="cat-emails",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        'requests>=2.26.0',
        'requests-mock>=1.11.0',
        'pydantic>=2.9.2'
    ],
)
